//! Julia code generation backend
//!
//! Generates Julia code using:
//! - DifferentialEquations.jl for ODE solving
//! - Turing.jl for Bayesian inference
//! - Distributions.jl for probability distributions

use crate::ir::*;
use std::fmt::Write;

/// Generate Julia code from IR
pub fn generate_julia(ir: &IRProgram) -> Result<String, std::fmt::Error> {
    let mut output = String::new();

    // Header
    generate_header(&mut output, ir)?;

    // Imports
    generate_imports(&mut output)?;

    // ODE system function
    generate_ode_function(&mut output, ir)?;

    // Turing model
    generate_turing_model(&mut output, ir)?;

    Ok(output)
}

fn generate_header(output: &mut String, ir: &IRProgram) -> Result<(), std::fmt::Error> {
    writeln!(output, "# Generated by MedLang compiler")?;
    writeln!(output, "# Model: {}", ir.model.name)?;
    writeln!(
        output,
        "# Backend: Julia (DifferentialEquations.jl + Turing.jl)"
    )?;
    writeln!(output)?;
    Ok(())
}

fn generate_imports(output: &mut String) -> Result<(), std::fmt::Error> {
    writeln!(output, "using DifferentialEquations")?;
    writeln!(output, "using Turing")?;
    writeln!(output, "using Distributions")?;
    writeln!(output, "using DataFrames")?;
    writeln!(output, "using LinearAlgebra")?;
    writeln!(output)?;
    Ok(())
}

fn generate_ode_function(output: &mut String, ir: &IRProgram) -> Result<(), std::fmt::Error> {
    writeln!(output, "# ODE system for {}", ir.model.name)?;
    writeln!(output, "function ode_system!(du, u, p, t)")?;

    // Unpack state variables
    for (i, state) in ir.model.states.iter().enumerate() {
        writeln!(output, "    {} = u[{}]", state.name, i + 1)?;
    }
    writeln!(output)?;

    // Unpack parameters
    for (i, param) in ir.model.params.iter().enumerate() {
        if matches!(param.kind, ParamKind::Fixed) {
            writeln!(output, "    {} = p[{}]", param.name, i + 1)?;
        }
    }
    writeln!(output)?;

    // ODE equations
    writeln!(output, "    # Differential equations")?;
    for (i, ode) in ir.model.odes.iter().enumerate() {
        write!(output, "    du[{}] = ", i + 1)?;
        generate_expr(output, &ode.rhs)?;
        writeln!(output)?;
    }

    writeln!(output, "end")?;
    writeln!(output)?;
    Ok(())
}

fn generate_turing_model(output: &mut String, ir: &IRProgram) -> Result<(), std::fmt::Error> {
    writeln!(output, "# Turing.jl probabilistic model")?;
    writeln!(
        output,
        "@model function {}(data, n_subjects)",
        ir.model.name
    )?;
    writeln!(output, "    # Extract data")?;
    writeln!(output, "    times = data.TIME")?;
    writeln!(output, "    observations = data.DV")?;
    writeln!(output, "    subject_ids = data.ID")?;

    // Covariates
    for input in &ir.model.inputs {
        writeln!(output, "    {} = data.{}", input.name, input.name)?;
    }
    writeln!(output)?;

    // Population parameter priors
    writeln!(output, "    # Population parameter priors")?;
    for param in &ir.model.params {
        match param.kind {
            ParamKind::PopulationMean => {
                generate_population_prior(output, &param.name)?;
            }
            ParamKind::PopulationVariance => {
                generate_variance_prior(output, &param.name)?;
            }
            _ => {}
        }
    }
    writeln!(output)?;

    // Random effects
    writeln!(output, "    # Inter-individual variability")?;
    for re in &ir.model.random_effects {
        writeln!(
            output,
            "    {} = Vector{{Float64}}(undef, n_subjects)",
            re.name
        )?;
        writeln!(output, "    for i in 1:n_subjects")?;
        match &re.distribution {
            IRDistribution::Normal { mu, sigma } => {
                write!(output, "        {}[i] ~ Normal(", re.name)?;
                generate_expr(output, mu)?;
                write!(output, ", ")?;
                generate_expr(output, sigma)?;
                writeln!(output, ")")?;
            }
            IRDistribution::LogNormal { mu, sigma } => {
                write!(output, "        {}[i] ~ LogNormal(", re.name)?;
                generate_expr(output, mu)?;
                write!(output, ", ")?;
                generate_expr(output, sigma)?;
                writeln!(output, ")")?;
            }
        }
        writeln!(output, "    end")?;
    }
    writeln!(output)?;

    // Individual parameters
    writeln!(output, "    # Individual parameters")?;
    for iparam in &ir.model.individual_params {
        writeln!(
            output,
            "    {} = Vector{{Float64}}(undef, n_subjects)",
            iparam.param_name
        )?;
        writeln!(output, "    for i in 1:n_subjects")?;

        // Weight normalization if needed
        if ir.model.inputs.iter().any(|inp| inp.name == "WT") {
            writeln!(output, "        w = WT[i] / 70.0  # Normalized weight")?;
        }

        write!(output, "        {}[i] = ", iparam.param_name)?;
        generate_expr_with_indexing(output, &iparam.expr)?;
        writeln!(output)?;
        writeln!(output, "    end")?;
    }
    writeln!(output)?;

    // Measurement error
    writeln!(output, "    # Measurement error model")?;
    if let Some(measure) = ir.measures.first() {
        if let Some(sigma_param) = measure.params.iter().find(|p| p.name.contains("sigma")) {
            generate_variance_prior(output, &sigma_param.name)?;
        }
    }
    writeln!(output)?;

    // Likelihood
    writeln!(output, "    # Likelihood")?;
    writeln!(output, "    for obs_idx in 1:length(observations)")?;
    writeln!(output, "        subj_id = subject_ids[obs_idx]")?;
    writeln!(output, "        t = times[obs_idx]")?;
    writeln!(output)?;

    // Solve ODE
    writeln!(output, "        # Solve ODE for this observation")?;
    writeln!(
        output,
        "        u0 = zeros({})  # Initial conditions",
        ir.model.states.len()
    )?;

    // Dosing (simplified for V0 - assumes single dose at t=0)
    writeln!(output, "        if t > 0.0")?;
    writeln!(
        output,
        "            u0[1] = 100.0  # Dose to first compartment (gut)"
    )?;
    writeln!(output, "        end")?;
    writeln!(output)?;

    // Parameter vector
    write!(output, "        p = [")?;
    let fixed_params: Vec<_> = ir
        .model
        .params
        .iter()
        .filter(|p| matches!(p.kind, ParamKind::Fixed))
        .collect();
    for (i, param) in fixed_params.iter().enumerate() {
        if i > 0 {
            write!(output, ", ")?;
        }
        write!(output, "{}[subj_id]", param.name)?;
    }
    writeln!(output, "]")?;

    writeln!(output, "        tspan = (0.0, t)")?;
    writeln!(
        output,
        "        prob = ODEProblem(ode_system!, u0, tspan, p)"
    )?;
    writeln!(
        output,
        "        sol = solve(prob, Tsit5(), saveat=[t], abstol=1e-8, reltol=1e-8)"
    )?;
    writeln!(output)?;

    // Compute prediction
    writeln!(output, "        # Compute predicted concentration")?;
    if let Some(_obs) = ir.model.observables.first() {
        write!(output, "        pred = ")?;
        // For C_plasma = A_central / V, we need to extract A_central and divide by V
        // Simplified: assume second state is A_central, V is second fixed param
        writeln!(
            output,
            "sol[2, end] / {}[subj_id]  # A_central / V",
            fixed_params.get(2).map(|p| p.name.as_str()).unwrap_or("V")
        )?;
    }
    writeln!(output)?;

    // Likelihood contribution
    writeln!(output, "        # Likelihood contribution")?;
    if let Some(measure) = ir.measures.first() {
        if let Some(sigma_param) = measure.params.iter().find(|p| p.name.contains("sigma")) {
            writeln!(
                output,
                "        observations[obs_idx] ~ Normal(pred, {} * pred)",
                sigma_param.name
            )?;
        } else {
            writeln!(
                output,
                "        observations[obs_idx] ~ Normal(pred, 0.1 * pred)"
            )?;
        }
    } else {
        writeln!(
            output,
            "        observations[obs_idx] ~ Normal(pred, 0.1 * pred)"
        )?;
    }
    writeln!(output, "    end")?;

    writeln!(output, "end")?;
    writeln!(output)?;
    Ok(())
}

fn generate_population_prior(output: &mut String, name: &str) -> Result<(), std::fmt::Error> {
    // Default priors for population parameters
    if name.contains("CL") {
        writeln!(output, "    {} ~ LogNormal(log(10.0), 1.0)", name)?;
    } else if name.contains("V") {
        writeln!(output, "    {} ~ LogNormal(log(50.0), 1.0)", name)?;
    } else if name.contains("Ka") {
        writeln!(output, "    {} ~ LogNormal(log(1.0), 1.0)", name)?;
    } else {
        writeln!(output, "    {} ~ LogNormal(0.0, 1.0)", name)?;
    }
    Ok(())
}

fn generate_variance_prior(output: &mut String, name: &str) -> Result<(), std::fmt::Error> {
    // Half-Cauchy priors for variance parameters
    writeln!(output, "    {} ~ truncated(Cauchy(0, 1), 0, Inf)", name)?;
    Ok(())
}

fn generate_expr(output: &mut String, expr: &IRExpr) -> Result<(), std::fmt::Error> {
    generate_expr_internal(output, expr, false)
}

fn generate_expr_with_indexing(output: &mut String, expr: &IRExpr) -> Result<(), std::fmt::Error> {
    generate_expr_internal(output, expr, true)
}

fn generate_expr_internal(
    output: &mut String,
    expr: &IRExpr,
    index_etas: bool,
) -> Result<(), std::fmt::Error> {
    match expr {
        IRExpr::Literal(val) => write!(output, "{}", val)?,
        IRExpr::Var(name) => {
            // Add [i] indexing for eta variables when in loop context
            if index_etas && name.starts_with("eta_") {
                write!(output, "{}[i]", name)?;
            } else {
                write!(output, "{}", name)?;
            }
        }
        IRExpr::Index(arr, idx) => {
            generate_expr_internal(output, arr, index_etas)?;
            write!(output, "[")?;
            generate_expr_internal(output, idx, index_etas)?;
            write!(output, "]")?;
        }
        IRExpr::Unary(op, operand) => match op {
            IRUnaryOp::Neg => {
                write!(output, "-")?;
                generate_expr_internal(output, operand, index_etas)?;
            }
        },
        IRExpr::Binary(op, left, right) => {
            write!(output, "(")?;
            generate_expr_internal(output, left, index_etas)?;
            match op {
                IRBinaryOp::Add => write!(output, " + ")?,
                IRBinaryOp::Sub => write!(output, " - ")?,
                IRBinaryOp::Mul => write!(output, " * ")?,
                IRBinaryOp::Div => write!(output, " / ")?,
                IRBinaryOp::Pow => write!(output, " ^ ")?,
            }
            generate_expr_internal(output, right, index_etas)?;
            write!(output, ")")?;
        }
        IRExpr::Call(func, args) => {
            // Map pow(a, b) to a^b in Julia
            if func == "pow" && args.len() == 2 {
                write!(output, "(")?;
                generate_expr_internal(output, &args[0], index_etas)?;
                write!(output, " ^ ")?;
                generate_expr_internal(output, &args[1], index_etas)?;
                write!(output, ")")?;
            } else {
                write!(output, "{}(", func)?;
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 {
                        write!(output, ", ")?;
                    }
                    generate_expr_internal(output, arg, index_etas)?;
                }
                write!(output, ")")?;
            }
        }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_julia_header() {
        let ir = IRProgram {
            model: IRModel {
                name: "TestModel".to_string(),
                states: vec![],
                params: vec![],
                inputs: vec![],
                random_effects: vec![],
                intermediates: vec![],
                odes: vec![],
                observables: vec![],
                individual_params: vec![],
            },
            measures: vec![IRMeasure {
                name: "TestMeasure".to_string(),
                observable_ref: "Y".to_string(),
                params: vec![],
                log_likelihood: IRExpr::Literal(0.0),
            }],
            data_spec: IRDataSpec {
                n_subjects: "N".to_string(),
                n_obs: "n_obs".to_string(),
                columns: std::collections::HashMap::new(),
            },
            externals: vec![],
        };

        let julia_code = generate_julia(&ir).unwrap();
        assert!(julia_code.contains("# Generated by MedLang compiler"));
        assert!(julia_code.contains("# Model: TestModel"));
        assert!(julia_code.contains("using DifferentialEquations"));
        assert!(julia_code.contains("using Turing"));
    }

    #[test]
    fn test_expr_generation() {
        let mut output = String::new();

        // Test literal
        generate_expr(&mut output, &IRExpr::Literal(3.14)).unwrap();
        assert_eq!(output, "3.14");

        // Test variable
        output.clear();
        generate_expr(&mut output, &IRExpr::Var("x".to_string())).unwrap();
        assert_eq!(output, "x");

        // Test binary operation
        output.clear();
        let expr = IRExpr::Binary(
            IRBinaryOp::Add,
            Box::new(IRExpr::Var("a".to_string())),
            Box::new(IRExpr::Var("b".to_string())),
        );
        generate_expr(&mut output, &expr).unwrap();
        assert_eq!(output, "(a + b)");

        // Test power
        output.clear();
        let expr = IRExpr::Binary(
            IRBinaryOp::Pow,
            Box::new(IRExpr::Var("w".to_string())),
            Box::new(IRExpr::Literal(0.75)),
        );
        generate_expr(&mut output, &expr).unwrap();
        assert_eq!(output, "(w ^ 0.75)");

        // Test function call (exp)
        output.clear();
        let expr = IRExpr::Call("exp".to_string(), vec![IRExpr::Var("eta".to_string())]);
        generate_expr(&mut output, &expr).unwrap();
        assert_eq!(output, "exp(eta)");
    }
}
