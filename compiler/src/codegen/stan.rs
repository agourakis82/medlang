//! Stan code generator
//!
//! Generates Stan code from IR for Bayesian inference with NLME models.
//!
//! Stan program structure:
//! - functions: ODE system definition
//! - data: observed data and constants
//! - parameters: population parameters and random effects
//! - transformed parameters: individual parameters and predictions
//! - model: prior and likelihood

use crate::ir::*;
use std::fmt::Write;

/// Generate complete Stan program from IR
pub fn generate_stan(ir: &IRProgram) -> Result<String, std::fmt::Error> {
    let mut output = String::new();

    // Header comment
    writeln!(output, "// Generated by MedLang compiler")?;
    writeln!(output, "// Model: {}", ir.model.name)?;
    writeln!(output)?;

    // Generate each block
    generate_functions_block(&mut output, ir)?;
    generate_data_block(&mut output, ir)?;
    generate_parameters_block(&mut output, ir)?;
    generate_transformed_parameters_block(&mut output, ir)?;
    generate_model_block(&mut output, ir)?;

    Ok(output)
}

/// Generate functions block (ODE system)
fn generate_functions_block(output: &mut String, ir: &IRProgram) -> Result<(), std::fmt::Error> {
    writeln!(output, "functions {{")?;
    writeln!(output, "  // ODE system for {}", ir.model.name)?;

    // Function signature
    write!(output, "  vector ode_system(real t, vector y")?;

    // Add parameters as arguments
    for param in &ir.model.params {
        if matches!(param.kind, ParamKind::Fixed) {
            write!(output, ", real {}", param.name)?;
        }
    }
    writeln!(output, ") {{")?;

    // Unpack state vector
    for (i, state) in ir.model.states.iter().enumerate() {
        writeln!(output, "    real {} = y[{}];", state.name, i + 1)?;
    }

    writeln!(output)?;

    // Compute intermediate values (let bindings)
    if !ir.model.intermediates.is_empty() {
        writeln!(output, "    // Intermediate values")?;
        for intermediate in &ir.model.intermediates {
            write!(output, "    real {} = ", intermediate.name)?;
            generate_expr(output, &intermediate.expr)?;
            writeln!(output, ";")?;
        }
        writeln!(output)?;
    }

    // Compute derivatives
    writeln!(output, "    vector[{}] dydt;", ir.model.states.len())?;
    for (i, ode) in ir.model.odes.iter().enumerate() {
        write!(output, "    dydt[{}] = ", i + 1)?;
        generate_expr(output, &ode.rhs)?;
        writeln!(output, ";")?;
    }

    writeln!(output)?;
    writeln!(output, "    return dydt;")?;
    writeln!(output, "  }}")?;
    writeln!(output, "}}")?;
    writeln!(output)?;

    Ok(())
}

/// Generate data block
fn generate_data_block(output: &mut String, ir: &IRProgram) -> Result<(), std::fmt::Error> {
    writeln!(output, "data {{")?;
    writeln!(output, "  // Dataset dimensions")?;
    writeln!(
        output,
        "  int<lower=1> {};  // Number of subjects",
        ir.data_spec.n_subjects
    )?;
    writeln!(
        output,
        "  int<lower=1> {};  // Total observations",
        ir.data_spec.n_obs
    )?;
    writeln!(output)?;

    writeln!(output, "  // Observations")?;
    writeln!(
        output,
        "  array[{}] int<lower=1,upper={}> subject_id;",
        ir.data_spec.n_obs, ir.data_spec.n_subjects
    )?;
    writeln!(output, "  vector[{}] time;", ir.data_spec.n_obs)?;
    writeln!(output, "  vector[{}] observation;", ir.data_spec.n_obs)?;
    writeln!(output)?;

    // Covariates
    if !ir.model.inputs.is_empty() {
        writeln!(output, "  // Covariates")?;
        for input in &ir.model.inputs {
            writeln!(
                output,
                "  vector[{}] {};",
                ir.data_spec.n_subjects, input.name
            )?;
        }
        writeln!(output)?;
    }

    // Dosing information
    writeln!(output, "  // Dosing")?;
    writeln!(output, "  real dose_amount;  // Dose amount")?;
    writeln!(output, "  real dose_time;    // Dose time")?;
    writeln!(output)?;

    // ODE solver settings
    writeln!(output, "  // ODE solver settings")?;
    writeln!(output, "  real rtol;  // Relative tolerance")?;
    writeln!(output, "  real atol;  // Absolute tolerance")?;
    writeln!(output, "  int max_steps;  // Maximum steps")?;

    // External quantum constants
    if !ir.externals.is_empty() {
        writeln!(output)?;
        writeln!(output, "  // External quantum constants")?;
        for ext in &ir.externals {
            writeln!(
                output,
                "  real<lower=0> {};  // from {}",
                ext.name, ext.source
            )?;
        }
    }

    writeln!(output, "}}")?;
    writeln!(output)?;

    Ok(())
}

/// Generate parameters block
fn generate_parameters_block(output: &mut String, ir: &IRProgram) -> Result<(), std::fmt::Error> {
    writeln!(output, "parameters {{")?;
    writeln!(output, "  // Population parameters")?;

    // Population means
    for param in &ir.model.params {
        if matches!(param.kind, ParamKind::PopulationMean) {
            writeln!(output, "  real<lower=0> {};", param.name)?;
        }
    }

    writeln!(output)?;

    // Population variances
    writeln!(output, "  // Population variability (SD)")?;
    for param in &ir.model.params {
        if matches!(param.kind, ParamKind::PopulationVariance) {
            writeln!(output, "  real<lower=0> {};", param.name)?;
        }
    }

    writeln!(output)?;

    // Random effects (subject-level)
    if !ir.model.random_effects.is_empty() {
        writeln!(output, "  // Random effects (standardized)")?;
        for re in &ir.model.random_effects {
            writeln!(output, "  vector[{}] {};", ir.data_spec.n_subjects, re.name)?;
        }
        writeln!(output)?;
    }

    // Error model parameters
    writeln!(output, "  // Error model")?;
    for measure in &ir.measures {
        for param in &measure.params {
            writeln!(output, "  real<lower=0> {};", param.name)?;
        }
    }

    writeln!(output, "}}")?;
    writeln!(output)?;

    Ok(())
}

/// Generate transformed parameters block
fn generate_transformed_parameters_block(
    output: &mut String,
    ir: &IRProgram,
) -> Result<(), std::fmt::Error> {
    writeln!(output, "transformed parameters {{")?;
    writeln!(output, "  // Individual parameters")?;

    // Individual parameter arrays
    for param in &ir.model.individual_params {
        writeln!(
            output,
            "  vector[{}] {};",
            ir.data_spec.n_subjects, param.param_name
        )?;
    }

    writeln!(output)?;

    // Compute individual parameters
    writeln!(output, "  for (i in 1:{}) {{", ir.data_spec.n_subjects)?;

    // Add weight normalization if WT is used
    if ir.model.inputs.iter().any(|inp| inp.name == "WT") {
        writeln!(output, "    real w = WT[i] / 70.0;  // Normalized weight")?;
    }

    for iparam in &ir.model.individual_params {
        write!(output, "    {}[i] = ", iparam.param_name)?;
        generate_expr_with_index(output, &iparam.expr, "i")?;
        writeln!(output, ";")?;
    }
    writeln!(output, "  }}")?;

    writeln!(output, "}}")?;
    writeln!(output)?;

    Ok(())
}

/// Generate model block (priors and likelihood)
fn generate_model_block(output: &mut String, ir: &IRProgram) -> Result<(), std::fmt::Error> {
    writeln!(output, "model {{")?;
    writeln!(output, "  // Priors")?;

    // Population parameter priors
    for param in &ir.model.params {
        match param.kind {
            ParamKind::PopulationMean => {
                writeln!(
                    output,
                    "  {} ~ lognormal(0, 2);  // Weakly informative",
                    param.name
                )?;
            }
            ParamKind::PopulationVariance => {
                writeln!(output, "  {} ~ cauchy(0, 1);  // Half-Cauchy", param.name)?;
            }
            _ => {}
        }
    }

    writeln!(output)?;

    // Random effects priors
    writeln!(output, "  // Random effects")?;
    for re in &ir.model.random_effects {
        match &re.distribution {
            IRDistribution::Normal { mu, sigma } => {
                write!(output, "  {} ~ normal(", re.name)?;
                generate_expr(output, mu)?;
                write!(output, ", ")?;
                generate_expr(output, sigma)?;
                writeln!(output, ");")?;
            }
            IRDistribution::LogNormal { mu, sigma } => {
                write!(output, "  {} ~ lognormal(", re.name)?;
                generate_expr(output, mu)?;
                write!(output, ", ")?;
                generate_expr(output, sigma)?;
                writeln!(output, ");")?;
            }
        }
    }

    writeln!(output)?;

    // Likelihood
    writeln!(output, "  // Likelihood")?;
    writeln!(output, "  for (i in 1:{}) {{", ir.data_spec.n_obs)?;
    writeln!(output, "    int subj = subject_id[i];")?;
    writeln!(output)?;

    // Solve ODE for this observation
    writeln!(output, "    // Solve ODE")?;
    writeln!(
        output,
        "    vector[{}] y0 = rep_vector(0.0, {});",
        ir.model.states.len(),
        ir.model.states.len()
    )?;

    // Set initial condition (dose in first compartment)
    writeln!(output, "    if (time[i] > dose_time) {{")?;
    writeln!(output, "      y0[1] = dose_amount;")?;
    writeln!(output, "    }}")?;
    writeln!(output)?;

    // ODE solve
    write!(output, "    array[1] vector[{}] y = ode_rk45(ode_system, y0, dose_time, {{time[i]}}, rtol, atol, max_steps", ir.model.states.len())?;

    // Add individual parameters as arguments
    for iparam in &ir.model.individual_params {
        write!(output, ", {}[subj]", iparam.param_name)?;
    }
    writeln!(output, ");")?;
    writeln!(output)?;

    // Compute prediction
    writeln!(output, "    // Compute prediction")?;
    if let Some(obs) = ir.model.observables.first() {
        write!(output, "    real pred = ")?;
        generate_expr_for_prediction(output, &obs.expr, "y[1]")?;
        writeln!(output, ";")?;
    }
    writeln!(output)?;

    // Likelihood contribution
    writeln!(output, "    // Likelihood contribution")?;
    write!(output, "    observation[i] ~ ")?;

    // Generate likelihood (simplified for V0 - single measure)
    writeln!(
        output,
        "normal(pred, {} * pred);",
        ir.measures
            .first()
            .and_then(|m| m.params.first())
            .map(|p| p.name.as_str())
            .unwrap_or("sigma")
    )?;

    writeln!(output, "  }}")?;

    writeln!(output, "}}")?;

    Ok(())
}

/// Generate expression code
fn generate_expr(output: &mut String, expr: &IRExpr) -> Result<(), std::fmt::Error> {
    match expr {
        IRExpr::Literal(val) => write!(output, "{}", val)?,
        IRExpr::Var(name) => write!(output, "{}", name)?,
        IRExpr::Index(arr, idx) => {
            generate_expr(output, arr)?;
            write!(output, "[")?;
            generate_expr(output, idx)?;
            write!(output, "]")?;
        }
        IRExpr::Unary(IRUnaryOp::Neg, operand) => {
            write!(output, "-")?;
            generate_expr(output, operand)?;
        }
        IRExpr::Binary(op, left, right) => {
            write!(output, "(")?;
            generate_expr(output, left)?;
            write!(output, " {} ", op_to_string(op))?;
            generate_expr(output, right)?;
            write!(output, ")")?;
        }
        IRExpr::Call(name, args) => {
            write!(output, "{}", name)?;
            write!(output, "(")?;
            for (i, arg) in args.iter().enumerate() {
                if i > 0 {
                    write!(output, ", ")?;
                }
                generate_expr(output, arg)?;
            }
            write!(output, ")")?;
        }
    }
    Ok(())
}

/// Generate expression with array indexing
fn generate_expr_with_index(
    output: &mut String,
    expr: &IRExpr,
    index: &str,
) -> Result<(), std::fmt::Error> {
    match expr {
        IRExpr::Var(name) => {
            // If it's a random effect or input, add index
            if name.starts_with("eta_") || name == "WT" {
                write!(output, "{}[{}]", name, index)?;
            } else {
                write!(output, "{}", name)?;
            }
        }
        IRExpr::Binary(op, left, right) => {
            write!(output, "(")?;
            generate_expr_with_index(output, left, index)?;
            write!(output, " {} ", op_to_string(op))?;
            generate_expr_with_index(output, right, index)?;
            write!(output, ")")?;
        }
        IRExpr::Call(name, args) => {
            write!(output, "{}", name)?;
            write!(output, "(")?;
            for (i, arg) in args.iter().enumerate() {
                if i > 0 {
                    write!(output, ", ")?;
                }
                generate_expr_with_index(output, arg, index)?;
            }
            write!(output, ")")?;
        }
        IRExpr::Unary(IRUnaryOp::Neg, operand) => {
            write!(output, "-")?;
            generate_expr_with_index(output, operand, index)?;
        }
        _ => generate_expr(output, expr)?,
    }
    Ok(())
}

/// Generate expression for prediction (accessing ODE solution)
fn generate_expr_for_prediction(
    output: &mut String,
    expr: &IRExpr,
    solution_var: &str,
) -> Result<(), std::fmt::Error> {
    match expr {
        IRExpr::Var(name) => {
            // Map state variable to solution vector
            if name == "A_central" {
                write!(output, "{}[2]", solution_var)?;
            } else if name == "A_gut" {
                write!(output, "{}[1]", solution_var)?;
            } else {
                write!(output, "{}", name)?;
            }
        }
        IRExpr::Binary(op, left, right) => {
            write!(output, "(")?;
            generate_expr_for_prediction(output, left, solution_var)?;
            write!(output, " {} ", op_to_string(op))?;
            generate_expr_for_prediction(output, right, solution_var)?;
            write!(output, ")")?;
        }
        _ => generate_expr(output, expr)?,
    }
    Ok(())
}

fn op_to_string(op: &IRBinaryOp) -> &'static str {
    match op {
        IRBinaryOp::Add => "+",
        IRBinaryOp::Sub => "-",
        IRBinaryOp::Mul => "*",
        IRBinaryOp::Div => "/",
        IRBinaryOp::Pow => "^",
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_expr() {
        let expr = IRExpr::binary(IRBinaryOp::Mul, IRExpr::var("Ka"), IRExpr::var("A_gut"));

        let mut output = String::new();
        generate_expr(&mut output, &expr).unwrap();

        assert_eq!(output, "(Ka * A_gut)");
    }

    #[test]
    fn test_op_to_string() {
        assert_eq!(op_to_string(&IRBinaryOp::Add), "+");
        assert_eq!(op_to_string(&IRBinaryOp::Mul), "*");
        assert_eq!(op_to_string(&IRBinaryOp::Pow), "^");
    }

    #[test]
    fn test_qm_externals_in_data_block() {
        use std::collections::HashMap;

        let ir = IRProgram {
            model: IRModel {
                name: "TestQM".to_string(),
                states: vec![],
                params: vec![],
                inputs: vec![],
                random_effects: vec![],
                intermediates: vec![],
                odes: vec![],
                observables: vec![],
                individual_params: vec![],
            },
            measures: vec![],
            data_spec: IRDataSpec {
                n_subjects: "N".to_string(),
                n_obs: "n_obs".to_string(),
                columns: HashMap::new(),
            },
            externals: vec![
                IRExternalScalar {
                    name: "Kd_QM".to_string(),
                    value: 2.5e-9,
                    source: "qm_stub:LIG001:EGFR".to_string(),
                    dimension: Some("ConcMass".to_string()),
                },
                IRExternalScalar {
                    name: "Kp_tumor_QM".to_string(),
                    value: 5.05,
                    source: "qm_stub:LIG001:dG_part".to_string(),
                    dimension: None,
                },
            ],
        };

        let stan_code = generate_stan(&ir).unwrap();

        // Check that QM constants appear in data block
        assert!(stan_code.contains("// External quantum constants"));
        assert!(stan_code.contains("real<lower=0> Kd_QM;"));
        assert!(stan_code.contains("from qm_stub:LIG001:EGFR"));
        assert!(stan_code.contains("real<lower=0> Kp_tumor_QM;"));
        assert!(stan_code.contains("from qm_stub:LIG001:dG_part"));
    }
}
