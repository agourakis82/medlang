use medlangc::codegen::julia::generate_julia;
/// Tests for Julia backend code generation
use medlangc::lexer::tokenize;
use medlangc::lower::lower_program;
use medlangc::parser::parse_program;
use std::fs;
use std::path::Path;

/// Helper to compile MedLang source to Julia
fn compile_to_julia(source: &str) -> String {
    let tokens = tokenize(source).expect("Tokenization failed");
    let ast = parse_program(&tokens).expect("Parsing failed");
    let ir = lower_program(&ast).expect("Lowering failed");
    generate_julia(&ir).expect("Code generation failed")
}

#[test]
fn test_julia_header_and_imports() {
    let source_path =
        Path::new(env!("CARGO_MANIFEST_DIR")).join("../docs/examples/one_comp_oral_pk.medlang");

    let source = fs::read_to_string(&source_path).expect("Failed to read canonical example");

    let julia_code = compile_to_julia(&source);

    // Check header
    assert!(julia_code.contains("# Generated by MedLang compiler"));
    assert!(julia_code.contains("# Model: OneCompOral"));
    assert!(julia_code.contains("# Backend: Julia"));

    // Check imports
    assert!(julia_code.contains("using DifferentialEquations"));
    assert!(julia_code.contains("using Turing"));
    assert!(julia_code.contains("using Distributions"));
    assert!(julia_code.contains("using DataFrames"));
    assert!(julia_code.contains("using LinearAlgebra"));
}

#[test]
fn test_julia_ode_function() {
    let source_path =
        Path::new(env!("CARGO_MANIFEST_DIR")).join("../docs/examples/one_comp_oral_pk.medlang");

    let source = fs::read_to_string(&source_path).expect("Failed to read canonical example");

    let julia_code = compile_to_julia(&source);

    // Check ODE function signature
    assert!(julia_code.contains("function ode_system!(du, u, p, t)"));

    // Check state unpacking
    assert!(julia_code.contains("A_gut = u[1]"));
    assert!(julia_code.contains("A_central = u[2]"));

    // Check parameter unpacking
    assert!(julia_code.contains("Ka = p[1]"));
    assert!(julia_code.contains("CL = p[2]"));
    assert!(julia_code.contains("V = p[3]"));

    // Check ODE equations
    assert!(julia_code.contains("du[1] = (-Ka * A_gut)"));
    assert!(julia_code.contains("du[2] = ((Ka * A_gut) - ((CL / V) * A_central))"));
}

#[test]
fn test_julia_turing_model() {
    let source_path =
        Path::new(env!("CARGO_MANIFEST_DIR")).join("../docs/examples/one_comp_oral_pk.medlang");

    let source = fs::read_to_string(&source_path).expect("Failed to read canonical example");

    let julia_code = compile_to_julia(&source);

    // Check Turing model macro
    assert!(julia_code.contains("@model function OneCompOral(data, n_subjects)"));

    // Check data extraction
    assert!(julia_code.contains("times = data.TIME"));
    assert!(julia_code.contains("observations = data.DV"));
    assert!(julia_code.contains("subject_ids = data.ID"));
    assert!(julia_code.contains("WT = data.WT"));
}

#[test]
fn test_julia_population_priors() {
    let source_path =
        Path::new(env!("CARGO_MANIFEST_DIR")).join("../docs/examples/one_comp_oral_pk.medlang");

    let source = fs::read_to_string(&source_path).expect("Failed to read canonical example");

    let julia_code = compile_to_julia(&source);

    // Check population parameter priors
    assert!(julia_code.contains("CL_pop ~ LogNormal(log(10.0), 1.0)"));
    assert!(julia_code.contains("V_pop ~ LogNormal(log(50.0), 1.0)"));
    assert!(julia_code.contains("Ka_pop ~ LogNormal(log(1.0), 1.0)"));

    // Check variance priors (Half-Cauchy)
    assert!(julia_code.contains("omega_CL ~ truncated(Cauchy(0, 1), 0, Inf)"));
    assert!(julia_code.contains("omega_V ~ truncated(Cauchy(0, 1), 0, Inf)"));
    assert!(julia_code.contains("omega_Ka ~ truncated(Cauchy(0, 1), 0, Inf)"));
}

#[test]
fn test_julia_random_effects() {
    let source_path =
        Path::new(env!("CARGO_MANIFEST_DIR")).join("../docs/examples/one_comp_oral_pk.medlang");

    let source = fs::read_to_string(&source_path).expect("Failed to read canonical example");

    let julia_code = compile_to_julia(&source);

    // Check random effect declarations
    assert!(julia_code.contains("eta_CL = Vector{Float64}(undef, n_subjects)"));
    assert!(julia_code.contains("eta_V = Vector{Float64}(undef, n_subjects)"));
    assert!(julia_code.contains("eta_Ka = Vector{Float64}(undef, n_subjects)"));

    // Check random effect priors
    assert!(julia_code.contains("eta_CL[i] ~ Normal(0, omega_CL)"));
    assert!(julia_code.contains("eta_V[i] ~ Normal(0, omega_V)"));
    assert!(julia_code.contains("eta_Ka[i] ~ Normal(0, omega_Ka)"));
}

#[test]
fn test_julia_individual_parameters() {
    let source_path =
        Path::new(env!("CARGO_MANIFEST_DIR")).join("../docs/examples/one_comp_oral_pk.medlang");

    let source = fs::read_to_string(&source_path).expect("Failed to read canonical example");

    let julia_code = compile_to_julia(&source);

    // Check individual parameter vectors
    assert!(julia_code.contains("CL = Vector{Float64}(undef, n_subjects)"));
    assert!(julia_code.contains("V = Vector{Float64}(undef, n_subjects)"));
    assert!(julia_code.contains("Ka = Vector{Float64}(undef, n_subjects)"));

    // Check weight normalization
    assert!(julia_code.contains("w = WT[i] / 70.0  # Normalized weight"));

    // Check allometric scaling with proper operators
    assert!(julia_code.contains("(w ^ 0.75)")); // Power operator, not pow()

    // Check proper eta indexing
    assert!(julia_code.contains("exp(eta_CL[i])"));
    assert!(julia_code.contains("exp(eta_V[i])"));
    assert!(julia_code.contains("exp(eta_Ka[i])"));
}

#[test]
fn test_julia_ode_solving() {
    let source_path =
        Path::new(env!("CARGO_MANIFEST_DIR")).join("../docs/examples/one_comp_oral_pk.medlang");

    let source = fs::read_to_string(&source_path).expect("Failed to read canonical example");

    let julia_code = compile_to_julia(&source);

    // Check ODE problem setup
    assert!(julia_code.contains("u0 = zeros(2)  # Initial conditions"));
    assert!(julia_code.contains("p = [Ka[subj_id], CL[subj_id], V[subj_id]]"));
    assert!(julia_code.contains("tspan = (0.0, t)"));

    // Check ODE solver call
    assert!(julia_code.contains("prob = ODEProblem(ode_system!, u0, tspan, p)"));
    assert!(julia_code.contains("sol = solve(prob, Tsit5()"));
    assert!(julia_code.contains("abstol=1e-8, reltol=1e-8"));
}

#[test]
fn test_julia_likelihood() {
    let source_path =
        Path::new(env!("CARGO_MANIFEST_DIR")).join("../docs/examples/one_comp_oral_pk.medlang");

    let source = fs::read_to_string(&source_path).expect("Failed to read canonical example");

    let julia_code = compile_to_julia(&source);

    // Check measurement error prior
    assert!(julia_code.contains("sigma_prop ~ truncated(Cauchy(0, 1), 0, Inf)"));

    // Check likelihood loop
    assert!(julia_code.contains("for obs_idx in 1:length(observations)"));

    // Check prediction computation
    assert!(julia_code.contains("pred = sol[2, end] / V[subj_id]  # A_central / V"));

    // Check likelihood contribution
    assert!(julia_code.contains("observations[obs_idx] ~ Normal(pred, sigma_prop * pred)"));
}

#[test]
fn test_julia_syntax_validity() {
    let source_path =
        Path::new(env!("CARGO_MANIFEST_DIR")).join("../docs/examples/one_comp_oral_pk.medlang");

    let source = fs::read_to_string(&source_path).expect("Failed to read canonical example");

    let julia_code = compile_to_julia(&source);

    // Check no Stan-specific syntax leaked in
    assert!(!julia_code.contains("int<lower=1>"));
    assert!(!julia_code.contains("real<lower=0>"));
    assert!(!julia_code.contains("vector[N]"));

    // Check Julia-specific syntax
    assert!(julia_code.contains("Vector{Float64}"));
    assert!(julia_code.contains("for i in 1:n_subjects"));

    // Check all blocks end properly
    let function_count = julia_code.matches("function ").count();
    let end_count = julia_code.matches("\nend\n").count() + julia_code.matches("\nend").count();
    assert!(
        end_count >= function_count,
        "Missing 'end' keywords: {} functions but {} ends",
        function_count,
        end_count
    );
}

#[test]
fn test_julia_line_count() {
    let source_path =
        Path::new(env!("CARGO_MANIFEST_DIR")).join("../docs/examples/one_comp_oral_pk.medlang");

    let source = fs::read_to_string(&source_path).expect("Failed to read canonical example");

    let julia_code = compile_to_julia(&source);

    let line_count = julia_code.lines().count();
    // Should be approximately 98 lines for the canonical example
    assert!(
        line_count >= 90 && line_count <= 110,
        "Expected ~98 lines, got {}",
        line_count
    );
}

#[test]
fn test_julia_deterministic_output() {
    let source_path =
        Path::new(env!("CARGO_MANIFEST_DIR")).join("../docs/examples/one_comp_oral_pk.medlang");

    let source = fs::read_to_string(&source_path).expect("Failed to read canonical example");

    let output1 = compile_to_julia(&source);
    let output2 = compile_to_julia(&source);

    assert_eq!(
        output1, output2,
        "Julia code generation should be deterministic"
    );
}
